<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE MAN SYSTEM "mansivp.dtd">
<MAN>
<LANGUAGE>Fr</LANGUAGE>
<TITLE>adaptativethreshold</TITLE>
<TYPE>Boite à outil SIVP</TYPE>
<DATE>Aout, 2005</DATE>
<SHORT_DESCRIPTION name="adaptativethreshold(fr)">Applique un seuillage adaptatif</SHORT_DESCRIPTION>
<CALLING_SEQUENCE>
   <CALLING_SEQUENCE_ITEM>ima_out = adaptativethreshold(ima_in,param1,"méthode","type",param2,param3)</CALLING_SEQUENCE_ITEM>
</CALLING_SEQUENCE>
<PARAM>
<PARAM_INDENT>
   <PARAM_ITEM>
   <PARAM_NAME>ima_in</PARAM_NAME>
   <PARAM_DESCRIPTION>
   Matrice d'entrée
   </PARAM_DESCRIPTION>
   </PARAM_ITEM>
   <PARAM_ITEM>
   <PARAM_NAME>ima_out</PARAM_NAME>
   <PARAM_DESCRIPTION>
   Matrice de sortie
   </PARAM_DESCRIPTION>
   </PARAM_ITEM>
   <PARAM_ITEM>
   <PARAM_NAME>méthode</PARAM_NAME>
   <PARAM_DESCRIPTION>
   méthode de seuillage :
   
   L'algorithme Adaptivethreshold fonctionne selon deux méthodes : ADAPTIVE_THRESH_MEAN_C or ADAPTIVE_THRESH_GAUSSIAN_C.
   
   </PARAM_DESCRIPTION>
   </PARAM_ITEM>
   <PARAM_ITEM>
   <PARAM_NAME>type</PARAM_NAME>
   <PARAM_DESCRIPTION>
   Le type de seuillage doit être : 
	THRESH_BINARY, 
	THRESH_BINARY_INV,
   </PARAM_DESCRIPTION>
   </PARAM_ITEM>
   <PARAM_ITEM>
   <PARAM_NAME>Param1</PARAM_NAME>
   <PARAM_DESCRIPTION>
   Seuil maximum utilisé quel que soit le type de seuillage THRESH_BINARY ou THRESH_BINARY_INV.
   </PARAM_DESCRIPTION>
   </PARAM_ITEM>
   <PARAM_ITEM>
   <PARAM_NAME>param2</PARAM_NAME>
   <PARAM_DESCRIPTION>
   La taille du voisinage de pixel employé pour calculer la valeur seuillé pour chaque pixel : 3, 5, 7,
   </PARAM_DESCRIPTION>
   </PARAM_ITEM>
   <PARAM_ITEM>
   <PARAM_NAME>param3</PARAM_NAME>
   <PARAM_DESCRIPTION>
Pour les méthodes ADAPTIVE_THRESH_MEAN_C et ADAPTIVE_THRESH_GAUSSIAN_C c'est une constante soustraite de la moyenne pondérée, bien qu'elle puisse être négative.
   </PARAM_DESCRIPTION>
   </PARAM_ITEM>
   </PARAM_INDENT>
</PARAM>
<DESCRIPTION>
<P>
   <TT>adaptativethreshold</TT> La fonction cvAdaptiveThreshold trnsforme une image en niveaux de gris en image binaire selon les formules suivantes :
</P>
<P>
thresholdType=CV_THRESH_BINARY:
dst(x,y) = maxValue, if src(x,y)>T(x,y)
           0, otherwise
</P>
<P>
thresholdType=CV_THRESH_BINARY_INV:
dst(x,y) = 0, if src(x,y)>T(x,y)
           maxValue, otherwise
</P>
<P>
Ou TI est la valeur en chaque pixel.

Pour la méthode ADAPTIVE_THRESH_MEAN_C c'est une moyenne de blockSize × blockSize du voisinage de Pixel, soustrait par param3.

Pour la méthode ADAPTIVE_THRESH_GAUSSIAN_C c'est une moyenne pondéré(gaussian) de blockSize le × blockSize du voisinage de Pixel, soustrait par param3.

</P>

</DESCRIPTION>
<EXAMPLE><![CDATA[

//upgrade the size of the memory
stacksize(10000000); 

//load the picture
A=imread('/home/vincent/software/sivp/images/maison.jpg');

B=convert(A,'BGR2GRAY');

//call the rect SIVP function
//C=adaptativethreshold(B,200,'ADAPTIVE_THRESH_MEAN_C','THRESH_BINARY',3,1);
//C=adaptativethreshold(B,200,'ADAPTIVE_THRESH_MEAN_C','THRESH_BINARY',5,-1);
//C=adaptativethreshold(B,200,'ADAPTIVE_THRESH_GAUSSIAN_C','THRESH_BINARY_INV',7,2);
C=adaptativethreshold(B,200,'ADAPTIVE_THRESH_GAUSSIAN_C','THRESH_BINARY_INV',9,-2);

//conversion
C=double(C)/255;

//try to display the result
xbasc();
imshow(C);
imwrite(C,"/home/vincent/Desktop/image/adapth.png")

]]></EXAMPLE>
<!-- ================================= -->

<AUTHORS>
   <AUTHORS_ITEM name="ETIENNE"> ETIENNE Vincent &lt;vincent.etienne (AT) gmail DOT com &gt; </AUTHORS_ITEM>
</AUTHORS>
<!-- ================================= -->
<SECTION label="Bugs and Shortcomings">
<P>
</P>
</SECTION>
<!-- ================================= -->
<SECTION label="Availability">
The latest version of SIVP can be found at
<P><A href="http://sivp.sourceforge.net">http://sivp.sourceforge.net</A></P>
</SECTION>
<!-- ================================= -->
   <SEE_ALSO>
      <SEE_ALSO_ITEM> <LINK>threshold</LINK> </SEE_ALSO_ITEM>
      <SEE_ALSO_ITEM> <LINK></LINK> </SEE_ALSO_ITEM>
   </SEE_ALSO>
</MAN>
